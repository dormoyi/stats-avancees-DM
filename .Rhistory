#### DM de DORMOY et NIESSEN
rm(list=objects())
graphics.off()
############################
#### A COMPLETER:
grp_id = 'T' #à remplacer par le nom de votre groupe (voir sur Edunao)
setwd("~/Documents/projets_git/stats-avancees-DM") # pour Ines
############################
#### A NE PAS TOUCHER:
data_poll<-read.table("pollution.txt",sep=" ",header=T,dec=".")
dict = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM' )
set.seed(which(dict==grp_id))
idx = sample(1:length(data_poll$pollution))[1:80]
data_poll = data_poll[idx, ]
############################
#### SUITE DU FICHIER A COMPLETER:
############################
#### 1. Faire une ou des représentation(s) graphique(s) unidimensionnelle(s) des données et commenter
df = data_poll
dim(df) # 80 13
summary(df)
# we replace the character values by numbers
# pluie = 1, sec  = 0
df['pluie'][df['pluie'] == 'Sec'] <- as.numeric(0)
df['pluie'][df['pluie'] == 'Pluie'] <- as.numeric(1)
df['pluie'] <- lapply(df['pluie'] , function(x) if(is.character(x)) as.numeric(x) else x)
# Nord=1, Ouest=2, Sud=3, Est=4 (maybe we could one hot encode that later)
df['vent'][df['vent'] == 'Nord'] <- as.numeric(1)
df['vent'][df['vent'] == 'Ouest'] <- as.numeric(2)
df['vent'][df['vent'] == 'Sud'] <- as.numeric(3)
df['vent'][df['vent'] == 'Est'] <- as.numeric(4)
df['vent'] <- lapply(df['vent'] , function(x) if(is.character(x)) as.numeric(x) else x)
summary(df)
par(mfrow=c(1,2),oma=c(0,0,3,0))
pluie.table=table(df$pluie)
pie(pluie.table,col=rainbow(4),main="Ratio des jours de pluie")
title(main="Plots des jours de vent et de",
outer=TRUE)
vent.table=table(df$vent)
pie(vent.table,col=rainbow(4),main="Ratio des jours de vent")
plot(df$pollution, main="Pollution en fonction du point dans le dataset")
plot(df$T9, main="Pollution en fonction du point dans le dataset")
plot(df$T9, type = "l", col = 1)  # Plot with Base R
lines(df$T12, type = "l", col = 2)
lines(df$T15, type = "l", col = 3)
title(main="Températures aux différentes heures de la jounée pour chaque point",
outer=FALSE)
par(mfrow=c(1,2),oma=c(0,0,3,0))
pluie.table=table(df$pluie)
pie(pluie.table,col=rainbow(4),main="Ratio des jours de pluie")
title(main="Plots des jours de vent et de",
outer=TRUE)
vent.table=table(df$vent)
pie(vent.table,col=rainbow(4),main="Ratio des jours de vent")
plot(df$pollution, main="Pollution en fonction du point dans le dataset")
plot(df$T9, type = "l", col = 1)  # Plot with Base R
lines(df$T12, type = "l", col = 2)
lines(df$T15, type = "l", col = 3)
title(main="Températures aux différentes heures de la jounée pour chaque point",
outer=FALSE)
############################
#### 2.
pairs(df) #trace tous les graphes à 2 variables possibles
# les variables de température semblent assez corrélées entre elles
plot(df$vent,df$pollution, main="Pollution en fonction du point dans le dataset")
plot(df$vent,df$pollution, main="Pollution en fonction du vent")
############################
#### 2. Faire une ou des représentation(s) graphique(s) illustrant les corrélations entre les variables et
#commenter.
pairs(df) #trace tous les graphes à 2 variables possibles
plot(df$vent,df$pollution, main="Pollution en fonction du vent")
############################
lm1=lm(pollution~.,data=df)
summary(lm1)
lm1$coefficients # beta chapeau
summary(lm1)
param_estim = model8$coefficients(5)
param_estim = lm1$coefficients(5)
param_estim = lm1$coefficients[5]
param_estim
param_estim = lm1$coefficients[9]
param_estim
?lm
confint(lm1)
## ------------------------------------------------------------------------
#
setwd("~/disque_tera/1_cs/2A/sg8 stats/TP2") # à personnaliser
rm(list=objects())
graphics.off()
## 1.1 ------------------------------------------------------------------------
#df = Prostate
df=read.table("prostate.txt",sep=";",header=TRUE)
Prostate = df
dim(df)
nrow(df)
## 1.2 ------------------------------------------------------------------------
summary(df)
apply(Prostate,2,mean)
apply(Prostate,2,sd)
apply(Prostate,2,function(x){c(mu=mean(x),sd=sd(x))})
pairs(df) #trace tous les graphes à 2 variables possibles
cor(df) #matrice de covariance
install.packages("corrplot")
library(corrplot)
corrplot(cor(df))
## 1.4 ------------------------------------------------------------------------
X=as.matrix(Prostate[,1:8])
X=cbind(intercept=1,X) # on rajoute l'intercept à notre matrice de design
Y=as.matrix(Prostate$lpsa,ncol=1) # vraies observations de lpsa
beta_est=solve(t(X)%*%X)%*% t(X)%*%Y # solves the equation a %*% x = b for x, where b can be either a vector or a matrix, par defaud b=Id
n=length(Y)
p=ncol(X)
sigma_est=sqrt(sum( (X%*%beta_est -Y)^2   )/(n-p)) # formule du cours
ddl=n-p # degres de liberte, ici p = p-1 du cours car on a rajouté l'intercept
V= solve(t(X)%*%X) *sigma_est^2 # estimateur de la variance
stddev=sqrt(diag(V))
# statistique de test de student
# POUR BETA 1
alpha = 0.05
#t.test(df$lcavol, alternative="two.sided", mu=sigma_est)
# modèle Yi~N(mu, sigma^2) iid
# H0: Bi nul contre H1: Bi non nul
# sous H0 mu=3.53 la statistique de Student T~sim T(n-1)
# région de rejet de niveau 5%: R={ T>qt(1-alpha,n-1) }
tobs= (beta_est[2])/stddev[2]
tobs # 6.676756
qt(1-alpha/2,ddl) # 1.98729
# pour tout en meme temps
beta_est/stddev
2*pt(-abs(beta_est)/stddev,n-p) # 2.110634e-09
2*pt(-abs(beta_est)/stddev,n-p,lower.tail=FALSE)
# estimation
Y_est = X%*%beta_est
Y_est
Y_est[2] # 0.7240557
beta_est[2] #0.5870229
## 1.5 ------------------------------------------------------------------------
# 1. lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45, data=Prostate) # un intercept est quand meme pris en compte
model8=lm(lpsa~.,data=Prostate) # les 2 denieres colonnes sont tobs et la p value
# on a les étoiles pour dire si les vars sont importantes
summary(model8)
names(model8)
#"coefficients"  "residuals"     "effects"       "rank" = p         "fitted.values"  "assign"  on verra plus tard      "qr"            "df.residual"
# "xlevels"       "call"          "terms"         "model"
# see meaning doing ?lm
model8$coefficients # beta chapeau
# 2.
#à compléter
predict(model8)
model8$fitted # c pareil
## 1.6------------------------------------------------------------------------
#1. Calculer un intervalle de confiance de niveau 95% pour chacun des paramètres du modèle (on pourra
# utiliser les fonctions vcov et qt). Comparer avec les résultats de la fonction confint. Interpréter pour
#les variables age et lcavol
mat=vcov(model8)
ICplus = beta_est + qt(1-alpha/2,ddl)*sqrt(diag(mat))
ICmoins = beta_est - qt(1-alpha/2,ddl)*sqrt(diag(mat))
alpha=0.05
quant = qt(1-alpha/2,model8$df.residual)
V = vcov(model8)
stddev=sqrt(diag(V))
confint(model8)
model8$coefficients
confint(lm1)
#### DM de DORMOY et NIESSEN
rm(list=objects())
graphics.off()
############################
#### A COMPLETER:
grp_id = 'T' #à remplacer par le nom de votre groupe (voir sur Edunao)
setwd("~/Documents/projets_git/stats-avancees-DM") # pour Ines
############################
#### A NE PAS TOUCHER:
data_poll<-read.table("pollution.txt",sep=" ",header=T,dec=".")
dict = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM' )
set.seed(which(dict==grp_id))
idx = sample(1:length(data_poll$pollution))[1:80]
data_poll = data_poll[idx, ]
############################
#### SUITE DU FICHIER A COMPLETER:
############################
#### 1. Faire une ou des représentation(s) graphique(s) unidimensionnelle(s) des données et commenter
df = data_poll
dim(df) # 80 13
summary(df)
# we replace the character values by numbers
# pluie = 1, sec  = 0
df['pluie'][df['pluie'] == 'Sec'] <- as.numeric(0)
df['pluie'][df['pluie'] == 'Pluie'] <- as.numeric(1)
df['pluie'] <- lapply(df['pluie'] , function(x) if(is.character(x)) as.numeric(x) else x)
# Nord=1, Ouest=2, Sud=3, Est=4 (maybe we could one hot encode that later)
df['vent'][df['vent'] == 'Nord'] <- as.numeric(1)
df['vent'][df['vent'] == 'Ouest'] <- as.numeric(2)
df['vent'][df['vent'] == 'Sud'] <- as.numeric(3)
df['vent'][df['vent'] == 'Est'] <- as.numeric(4)
df['vent'] <- lapply(df['vent'] , function(x) if(is.character(x)) as.numeric(x) else x)
summary(df)
par(mfrow=c(1,2),oma=c(0,0,3,0))
pluie.table=table(df$pluie)
pie(pluie.table,col=rainbow(4),main="Ratio des jours de pluie")
title(main="Plots des jours de vent et de",
outer=TRUE)
vent.table=table(df$vent)
pie(vent.table,col=rainbow(4),main="Ratio des jours de vent")
plot(df$pollution, main="Pollution en fonction du point dans le dataset")
plot(df$T9, type = "l", col = 1)  # Plot with Base R
lines(df$T12, type = "l", col = 2)
lines(df$T15, type = "l", col = 3)
title(main="Températures aux différentes heures de la jounée pour chaque point",
outer=FALSE)
############################
#### 2. Faire une ou des représentation(s) graphique(s) illustrant les corrélations entre les variables et
#commenter.
pairs(df) #trace tous les graphes à 2 variables possibles
plot(df$vent,df$pollution, main="Pollution en fonction du vent")
lm1=lm(pollution~.,data=df)
summary(lm1)
param_estim = lm1$coefficients[9]
param_estim # 1.21385
confint(lm1)
lm1$coefficients
lm1=lm(pollution~.,data=df)
summary(lm1)
summary(lm1)
summary(lm1)
summary(lm1)
summary(lm1)
lm2=lm(pollution~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+vpollution+pluie,data=df)
summary(lm2)
lm3=lm(pollution~T9+T12+T15+Ne9+Ne15+Vx9+Vx12+Vx15+vpollution+pluie,data=df) # on enlève Ne12
lm3=lm(pollution~T9+T12+T15+Ne9+Ne15+Vx9+Vx12+Vx15+vpollution+pluie,data=df) # on enlève Ne12
summary(lm3) # Adjusted R-squared:  0.7433
lm4=lm(pollution~T9+T12+T15+Ne9+Ne15+Vx9+Vx12+vpollution+pluie,data=df) # on enlève Vx15
summary(lm4) # Adjusted R-squared:  0.7469
lm5=lm(pollution~T9+T12+T15+Ne9+Ne15+Vx12+vpollution+pluie,data=df) # on enlève Vx9
summary(lm5) # Adjusted R-squared:  0.7504
lm6=lm(pollution~T9+T12+Ne9+Ne15+Vx12+vpollution+pluie,data=df) # on enlève T15
summary(lm6) # Adjusted R-squared:  0.7537
lm7=lm(pollution~T9+T12+Ne9+Vx12+vpollution+pluie,data=df) # on enlève Ne15
summary(lm7) # Adjusted R-squared:  0.7567
lm8=lm(pollution~T9+T12+Ne9+Vx12+vpollution+pluie,data=df) # on enlève pluie
summary(lm8) # Adjusted R-squared:  0.7573
lm8=lm(pollution~T9+T12+Ne9+Vx12+vpollution,data=df) # on enlève pluie
summary(lm8) # Adjusted R-squared:  0.7573
lm8=lm(pollution~T9+T12+Ne9+Vx12+vpollution,data=df) # on enlève pluie
summary(lm8) # Adjusted R-squared:  0.7579
lm9=lm(pollution~T9+T12+Ne9+Vx12+vpollution,data=df) # on enlève T9
summary(lm9) # Adjusted R-squared:  0.7579
lm9=lm(pollution~T12+Ne9+Vx12+vpollution,data=df) # on enlève T9
summary(lm9) # Adjusted R-squared:  0.7579
summary(lm9) # Adjusted R-squared:  0.7541
summary(lm1) # Adjusted R-squared:  0.7395
library(MASS)
stepAIC(lm1,direction='both',trace=1) # backward ou forward ou both, trace=1 on affiche toutes les étapes
# AIC fait conerver les variables T9, T12, Ne9, Vx12, vpollution
# c'est aussi ce que l'on a trouvé précédement !
stepAIC(model8,k=log(n),trace=0)
# AIC fait conerver les variables T9, T12, Ne9, Vx12, vpollution
# c'est aussi ce que l'on a trouvé précédement !
stepAIC(lm1,k=log(n),trace=0)
############################
#### 11.
Y=as.matrix(df$pollution,ncol=1) # vraies observations de lpsa
n=length(Y)
library(MASS)
stepAIC(lm1,direction='both',trace=1) # backward ou forward ou both, trace=1 on affiche toutes les étapes
# AIC fait conerver les variables T9, T12, Ne9, Vx12, vpollution
# c'est aussi ce que l'on a trouvé précédement !
stepAIC(lm1,k=log(n),trace=0)
n
lm8=lm(pollution~T9+T12+Ne9+Vx12+vpollution,data=df) # on enlève pluie
summary(lm8) # Adjusted R-squared:  0.7579
lm9=lm(pollution~T12+Ne9+Vx12+vpollution,data=df) # on enlève T9
summary(lm9) # Adjusted R-squared:  0.7541
#
par(mfrow=c(2,2), oma=c(0,0,2,0))
#
plot(lmf$fitted,Prostate$lpsa,main="à compléter")
abline(0,1)
lmf = lm8
#
par(mfrow=c(2,2), oma=c(0,0,2,0))
#
plot(lmf$fitted,Prostate$lpsa,main="à compléter")
abline(0,1)
#
plot(lmf$fitted,lmf$residuals,main="à compléter")
library(MASS) # pour la fonction stdres
points(lmf$fitted,stdres(lmf), col=2,pch=2 )
points(lmf$fitted,studres(lmf),col=3,pch=3)
abline(h=2)
abline(h=-2)
legend("bottomright",c("à compléter", "à compléter", "à compléter"),col=1:3, pch=1:3,
cex=0.5)
#
qqnorm(studres(lmf),main="à compléter")
qqline(studres(lmf))
#
title(main="Validation en régression linéaire multiple", outer=TRUE)
lmf = lm8
# fenetre en 2x2,  marge haute pour titre general
par(mfrow=c(2,2), oma=c(0,0,2,0))
#
plot(lmf$fitted,Prostate$lpsa,main="ajustes/observes") # pour voir si la variation est aléatoire (bien répartie sur la droite, et de meme variance)
abline(0,1)
lmf = lm8
# fenetre en 2x2,  marge haute pour titre general
par(mfrow=c(2,2), oma=c(0,0,2,0))
#
plot(lmf$fitted,df$pollution,main="ajustes/observes") # pour voir si la variation est aléatoire (bien répartie sur la droite, et de meme variance)
abline(0,1)
#
plot(lmf$fitted,lmf$residuals,main="differents residus",ylim=c(-3,3))
abline(h=0,lty=2)
library(MASS)
plot(lmf$fitted,stdres(lmf), col=2,pch=2 ,ylim=c(-3,3),
main="résidus standardisés et studentisés")
points(lmf$fitted,studres(lmf),col=3,pch=3)
abline(h=2); abline(h=-2); abline(h=0,lty=2)
legend("bottomright",c( "stdres", "studres"),col=2:3, pch=2:3,cex=0.5)
#
qqnorm(studres(lmf),main="quantile-quantile plot")
qqline(studres(lmf))
#
title(main="Validation en régression linéaire multiple", outer=TRUE)
# 2.par(mfrow=c(2,2))
plot(lmf) # residus en fonction y chapeau, quantiles, distance de cook et points leviers (ici pas de points avec des distances trop grandes)
lmf = lm8
# fenetre en 2x2,  marge haute pour titre general
par(mfrow=c(2,2), oma=c(0,0,2,0))
#
plot(lmf$fitted,df$pollution,main="ajustes/observes") # pour voir si la variation est aléatoire (bien répartie sur la droite, et de meme variance)
abline(0,1)
plot(lmf$fitted,lmf$residuals,main="differents residus",ylim=c(-3,3))
abline(h=0,lty=2)
library(MASS)
plot(lmf$fitted,stdres(lmf), col=2,pch=2 ,ylim=c(-3,3),
main="résidus standardisés et studentisés")
points(lmf$fitted,studres(lmf),col=3,pch=3)
abline(h=2); abline(h=-2); abline(h=0,lty=2)
legend("bottomright",c( "stdres", "studres"),col=2:3, pch=2:3,cex=0.5)
#
qqnorm(studres(lmf),main="quantile-quantile plot")
qqline(studres(lmf))
#
title(main="Validation en régression linéaire multiple", outer=TRUE)
# 2.par(mfrow=c(2,2))
plot(lmf) # residus en fonction y chapeau, quantiles, distance de cook et points leviers (ici pas de points avec des distances trop grandes)
